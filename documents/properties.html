<!DOCTYPE html>
<html>
<head lang="en">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <title>Exact</title>

  <link href="../stylesheets/codemirror.css" rel="stylesheet">
  <link href="../stylesheets/alice.css" rel="stylesheet">
  <link href="../stylesheets/defaults.css" rel="stylesheet">
  <!--<link href="../stylesheets/index.css" rel="stylesheet">-->


</head>
<body>
<header class="header">
  <nav class="nav-bar">
    <h3 class="brand"><a href="../" class="logo">Exact</a></h3>
    <a class="menu-btn"></a>
    <ul class="menu-bar">
      <li><a href="../examples/todomvc.html" class="menu-item"> Examples </a></li>
      <li><a href="#" class="menu-item  active"> Documents </a></li>
      <li><a href="#" class="menu-item"> Downloads </a></li>
      <li><a href="#" class="menu-item"> Blogs </a></li>
      <li><a href="#" class="menu-item"> GitHub </a></li>
    </ul>
  </nav>
</header>
<div class="main">
  <aside class="side-bar">
    <div class="card">
      <h4>Overview</h4>
      <ul class="list">
        <li><a href="./" class="link">Introduction</a></li>
        <li><a href="./installation.html" class="link">Installation</a></li>
      </ul>
    </div>
    <div class="card">
      <h4>Events</h4>
      <ul class="list">
        <li><a href="./events.html#on-off" class="link">On / Off</a></li>
        <li><a href="./events.html#send-emit" class="link">Send / Emit</a></li>
        <li><a href="./events.html#keys-of-event" class="link">Keys of Event</a></li>
      </ul>
    </div>
    <div class="card">
      <h4>Properties</h4>
      <ul class="list">
        <li><a href="./properties.html#setting-property" class="link">Setting Property</a></li>
        <li><a href="./properties.html#declaring-descriptors" class="link">Declaring Descriptors</a></li>
        <li><a href="./properties.html#adding-validation" class="link">Adding Validation</a></li>
        <li><a href="./properties.html#dirty-marking" class="link">Dirty Marking</a></li>
        <li><a href="./properties.html#property-changed-event" class="link">Property-Changed Event</a></li>
      </ul>
    </div>
    <div class="card">
      <h4>Models</h4>
      <ul class="list">
        <li><a href="./models.html#store-for-object" class="link">Cache / Store for Object</a></li>
        <li><a href="./models.html#collection-for-array" class="link">Collection for Array</a></li>
      </ul>
    </div>
    <div class="card">
      <h4>Components</h4>
      <ul class="list">
        <li><a href="./shadow-skin-template.html" class="link">Shadow & Skin & Template</a></li>
        <li><a href="./components.html#using-template-strings-as-texts" class="link">Using Template Strings as Texts</a></li>
        <li><a href="./components.html#setting-attributes-of-elements" class="link">Setting Attributes of Elements</a></li>
        <li><a href="./components.html#syntax-of-events-style-class" class="link">Syntax of Events, Style, Class</a></li>
        <li><a href="./children-and-contents" class="link">Children and Contents</a></li>
        <li><a href="./lifecycle-and-hooks.html" class="link">Lifecycle and Hooks</a></li>
        <li><a href="./lists-and-itemadapters.html" class="link">Lists and ItemAdapters</a></li>
        <li><a href="./form-inputs.html" class="link">Form Inputs</a></li>
      </ul>
    </div>
    <div class="card">
      <h4>Bindings</h4>
      <ul class="list">
        <li><a href="./bindings.html#syntax" class="link">Syntax</a></li>
        <li><a href="./bindings.html#key-terms" class="link">Key Terms</a></li>
        <li><a href="./bindings.html#optional-filters" class="link">Optional Filters</a></li>
        <li><a href="./bindings.html#javaScript-expressions" class="link">JavaScript Expressions</a></li>
      </ul>
    </div>
    <div class="card">
      <h4>Tips</h4>
      <ul class="list">
        <li><a href="./data-flow.html" class="link">Data Flow</a></li>
        <li><a href="./using-mixins.html" class="link">Using Mixins</a></li>
        <li><a href="./merging-descriptors.html" class="link">Merging Descriptors</a></li>
        <li><a href="./binding-instance-methods.html" class="link">Binding Instance Methods</a></li>
        <li><a href="./using-res-to-manage-resources.html" class="link">Using RES to Manage resources</a></li>
        <li><a href="./using-objectutil-to-update-and-clone.html" class="link">Using ObjectUtil to Update or Clone</a></li>
      </ul>
    </div>
  </aside>
  <a class="side-btn">&gt;</a>
  <article class="article">
    <a id="setting-property"></a>
    <h2>Properties</h2>
    <p>Exact使用定制的、渐进增强的`set`方法，在设置属性值的前后，为一些类的对象属性提供验证、脏标记或更改通知的功能实现。
      当然，我们也可以使用ES5中的Object.defineProperty定义某个属性的setter，并在setter方法中自定义所需的功能。
    </p>
    <h4 >Setting Property</h4>
    <p>用实例方法`set`来设置一个或多个属性。
      在设置属性值的前后，可能会触发验证、脏标记或更改通知，这是在类的静态方法`set`中具体实现的。在继承或混入时，该静态方法可被扩展甚至重写。
      例如，Component是对Element的增强，Element.set方法中只实现了脏标记的功能，而Component.set方法中增加了属性验证和更改通知的功能。
      </p>
    <a id="declaring-descriptors"></a>
    <div class="code-box">
      <pre class="code-behind js-mode">
  element.set('active', false);
  element.set('title', 'nothing');
  element.set({
    active: true,     // `active`被标记为脏，但不会send('changed.active')
    title: 'nothing'  // `title`没有脏，也不会send('changed.title')
  });

  // 假设没有为component的属性`active`添加验证
  component.set('active', false);
  component.set('title', 'nothing');
  component.set({
    active: true,     // `active`被标记为脏，会send('changed.active')
    title: 'nothing'  // `title`没有脏，不会send('changed.title')
  });</pre>
    </div>
    <h4>Using Descriptors</h4>
    <p>在Exact内部，当`set`方法可用时，总是使用`set`方法来设置属性值。同时，Exact不妨碍我们使用ES5中的setter来实现`set`方法相同的功能，更为此提供了便捷的实现方式。
      只要在类的静态属性`descriptors`中声明一些属性名，Exact就会在首次初始化时使用Object.defineProperty方法（如果该方法可用）为这些属性定义一对getter/setter，
      使我们在用点语法为属性赋值时，亦能触发脏标记等行为。例如：</p>

    <div class="code-box">
      <pre class="code-behind">
  var SubComponent = Exact.defineClass({
    // 默认构造函数会调用父类构造函数
    // constructor: function() {
    //   Exact.Component.call(this);
    // },
    extend: Exact.Component,
    statics: {
      descriptors: [
        'title',
        'active'
      ]
    }
  });

  var subComponent = new SubComponent();
  subComponent.title = 'abc'; // 等效于subComponent.set('title', 'abc');
  subComponent.active = true; // 等效于subComponent.set('active', true);
  subComponent.undeclared = true; // 与subComponent.set('undeclared', true)就有差别了</pre>
    </div>
    <p>这里使用了Exact的工具方法defineClass，但并没有使用什么魔法。你依然可以用你喜欢的方式定义一个类，例如使用ES6的语法糖。
      重要的是，在子类构造函数中调用了父类的构造函数。</p>
    <a id="adding-validation"></a>
    <div class="code-box">
      <pre class="code-behind js-mode">
  // 在ES6中
  class SubComponent extends Exact.Component {
    // 默认构造函数会调用父类构造函数
    // constructor() {
    //   super();
    // }
  }
  SubComponent.descriptors = ['title', 'active'];

  // 或者，在ES5中
  function SubComponent() {
    Exact.Component.call(this); // 调用父类构造函数
  }
  SubComponent.prototype = Object.create(Exact.Component);
  SubComponent.constructor = SubComponent;
  SubComponent.descriptors = ['title', 'active'];</pre>
    </div>
    <h4>Adding Validation</h4>
    <p>一些场景下，我们在为某个属性赋值之前，可能需要验证一下值的类型或其他因素。Exact中的Component和Store是支持验证机制的。
      为此，我们可以在`descriptors`的最后这样进行定义：</p>
    <div class="code-box">
      <pre class="code-behind js-mode">
  SubComponent.descriptors = ['a', 'b', {
    // 对于boolean、number、string类型
    title: 'string',
    amount: 'number',
    active: 'boolean',

    // 对于Object类型
    tool: Knife, // Knife是类的构造函数
    items: Array,

    // 以上是简单的类型验证，亦可允许多类型，模式匹配或自定义一个验证函数
    date: {
      type: ['number', 'string', Date]
    },
    score: {
      type: 'number',
      validate: function(value) {
        if (value < 0 || value > 100) {
          return new Error('out of the range 0~100');
        }
      }
    },
    username: {
      pattern: /^[a-zA-Z0-9]{1,32}$/,
      validate: function(value) {
        // ...
      }
    }
  }];</pre>
    </div>
    <a id="dirty-marking"></a>
    <p>于是，`date`属性可接收的值包括123456、"2016/11/18"或者Date对象；`score`的数字范围需在区间[0,100]上；`username`属性接收的值与模式不匹配时，不会将该值赋给`username`，而会派发 `invalid.username` 的事件。</p>
    <h4>Dirty Marking</h4>
    <p>脏标记是与Shadow层的异步批量渲染有关的，在Shadow及其子类，以及Cache的`set`方法中被用到。它的目的是为了标记一下当前哪个属性发生了变化，以便于下一刻Shadow层将脏了的属性的新值渲染到DOM层。
      一次完整的事件循环中，一个属性可能发生了一次或多次改变，并可能变回为原来的值。Shadow层关心的是即将进行下一批渲染时，真正发生改变的有哪些属性。</p>
    <a id="property-changed-event"></a>
    <div class="code-box">
      <pre class="code-behind js-mode">
  // 假设element的`title`的原值为null
  element.set('title', 'fine')
  console.log(element.hasDirty('title')); // 输出：true
  element.set('title', null)
  console.log(element.hasDirty('title')); // 输出：false</pre>
    </div>

    <h4>Property-Changed Event</h4>
    <p>当Component对象或Store对象的某个属性发生变化时，可能会派发这个属性改变的事件。数据的动态绑定要求绑定源属性的变化是可以探测到的，属性改变的事件正好满足了这个条件。
    我们可以将Component对象或Store对象的某个属性绑定到Element对象上，反之则起不到动态绑定的作用（但会完成一次赋值）。
    当数据绑定无法满足需求时，我们可以直接监听属性改变的事件，实现一些略复杂的逻辑。</p>
    <div class="code-box">
      <pre class="code-behind js-mode">
  store.on('changed', function(event) {
    // 监听所有属性的变化
  });
  store.on('changed.title', function(event) {
    // 只监听`title`属性的变化
  });</pre>
    </div>
    <h4>Custom Getter / Setter</h4>
    <p>通常，上述关于属性验证、脏标记和更改通知的行为描述是默认成立的。
      但如果你在`descriptors`中自定义了一对getter/setter，那就有可能改变默认的行为。
      因为，你可以在自定义的getter/setter中追加一些行为，也可以完全覆盖该类应有的属性行为。
      这时，一些验证项的声明可能是不宜的，最好是在自定义的setter中完成必要的验证。</p>
    <div class="code-box">
      <pre class="code-behind js-mode">
  var SubComponent = Exact.defineClass({
    extend: Exact.Component,
    statics: {
      descriptors: [{
        score: {
          type: 'number' // 此处声明不宜，在调用$set之前完成验证可能更好
          get: function() {
            return this.$get('score');
          },
          set: function(value) {
            // 强制裁剪
            value = value < 0 ? 0 : value;
            value = value > 100 ? 100 : value;

            this.$set('score', value); // 会触发验证、脏标记和更改通知
          }
        },
        time: {
          type: 'number', // 验证行为被覆盖，此处声明无效
          get: function() { return this._time; },
          set: function(value) { this._time = value; } // 单纯地赋值
        }
      }]
    }
  });

  var subComponent = new SubComponent();
  subComponent.score = 120;        // 先强制裁剪，而后触发验证、脏标记和更改通知
  console.log(subComponent.score); // 输出：100
  subComponent.time = 1000;        // 不会触发验证、脏标记或更改通知
  subComponent.set('time', 2000);  // 同样不会触发验证、脏标记或更改通知</pre>
    </div>
    <p>注意到，在已有基础上定义getter/setter时，我们用到了$get/$set，这两个特殊的方法只宜在自定义的getter/setter中使用。</p>
    </article>
</div>

<!--<footer class="footer">
  <p>Released under the MIT license<br>
    © 2015 Chen Junyong. All rights reserved.</p>
</footer>-->

<script src="../javascripts/codemirror.js"></script>
<script src="../javascripts/javascript-mode.js"></script>
<script src="../javascripts/code-format.js"></script>
<script src="../javascripts/menu.js"></script>
</body>
</html>